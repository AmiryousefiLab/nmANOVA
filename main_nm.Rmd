---
title: "nmANOVA main functions + paper examples"
output: html_notebook
---


#H0 holds for uniform
#nmANOVA(d, c( cluster1, cluster1,cluster1,cluster2,cluster2,cluster3), c( 'cluster2', 'cluster3') )
nmANOVA <- function( diss_data, partition, N_sampling = 1, subpartition = NULL ) {
  
  #diss_data - a numeric matrix or data.frame with dissimilarity measures,columns and rows should be in the same order
  #partition - a vector specifying the groups, it should be same length and in the same order as diss_data columns/rows 
  #subpartition - a vector of groups present in partition for which the method has to be applied to 
  #if subpartition is NULL, the method will be applied to all the groups present in partition ( unique( partition ) )
  
  if ( nrow( diss_data ) != ncol( diss_data ) )
    stop( "matrix has to be square" )
  
  if ( nrow( diss_data ) != length( partition ) )
    stop( "partition has to be same length as the number of row/columns in the matrix" )
  
  if ( N_sampling <= 0 )
    stop( "N_sampling has to be a positive integer" )
  
  if ( !is.null( subpartition ) & length( unique( subpartition ) ) < 2 )
    stop( "there should be at least two unique subpartitions" )
  
  
  
  partition <- as.factor( as.vector( partition ) )
  partition_sorted <- partition[ order( partition ) ]
  
  inner_partition_names <- vector()
  for ( i in 1:length( levels( partition_sorted ) ) ){
    inner_partition_names <- c( inner_partition_names, paste0( levels( partition_sorted )[i],'_', seq( 1:table( partition_sorted )[i] ) ) )
  }
  
  #set the names for each column/row based on a partition they belong to
  inner_partition_names <- inner_partition_names[ order( order ( partition ) ) ]
  partition_df <- as.data.frame( diss_data )
  colnames( partition_df ) <- inner_partition_names
  rownames( partition_df ) <- inner_partition_names
  
  #check if there is a subpartition provided  
  if ( !is.null( subpartition ) ){
    if ( length( unique( intersect( partition, subpartition ) ) ) !=  length( unique( subpartition )  )  )
      stop( "some elements from the subpartition do not match with partition" )
    subpartition <- as.factor( as.vector( subpartition ) )
    partition <- partition[ which( partition %in% intersect( partition, subpartition ) ) ]
  }
  
  selected_partitions <- which( sub('_[^_]*$', '', colnames( partition_df ) ) %in% partition )
  selected_partitions <- which( sub('_[^_]*$', '', rownames( partition_df ) ) %in% partition )
  partition_df <- partition_df[ selected_partitions, selected_partitions ]
  partition_df <- partition_df[ order( row.names( partition_df ) ), order( names( partition_df ) ) ]
  
  #the actual partition
  partition <- as.factor( sub('_[^_]*$', '', colnames( partition_df ) ) )
  #number of elements in each partition
  n_partition <- as.vector( table( partition ) )

  #calculate delta_w and delta_jj
  vec_within <- vector()
  delta_jj <- vector()
  SNM_w <- 0
  for( i in 1:length( levels( partition ) ) ){
    
    ind_partition <- which(  sub('_[^_]*$', '', colnames( partition_df ) ) == levels( partition )[i] )
    cur_partition <-  as.numeric( as.matrix( partition_df[ ind_partition, ind_partition ] ) )
    vec_within <- c( vec_within, cur_partition)
    delta_jj[i] <- mean( cur_partition, na.rm = TRUE )
    
  }
  
  delta_w <- mean( vec_within, na.rm = TRUE )
  
  #calculate SNM_w
  SNM_w <- 0
  for( i in 1:length( levels( partition ) ) ){
    
    ind_partition <- which(  sub('_[^_]*$', '', colnames( partition_df ) ) == levels( partition )[i] )
    cur_partition <-  as.numeric( as.matrix( partition_df[ ind_partition, ind_partition ] ) )
    
    n_cur_partition <- sum( is.na( cur_partition ) == FALSE )
 
   
    SNM_w <- SNM_w + n_cur_partition * (  ( delta_jj[i] - delta_w ) )^2
  }
  
  
  #calculate delta_jj', delta_prop and SNM_b
  
  off_diag_new <- 0
  for( i in 1:length( levels( partition ) ) ){
      for( j in 1:length( levels( partition ) ) ){
        if( i != j ){ 
          
          ind_row_partition <- which(  sub('_[^_]*$', '', colnames( partition_df ) ) == levels( partition )[i] )
          ind_col_partition <- which(  sub('_[^_]*$', '', colnames( partition_df ) ) == levels( partition )[j] )
          cur_partition <-  as.numeric( as.matrix( partition_df[ ind_row_partition, ind_col_partition ] ) )
          
          off_diag_new <- off_diag_new +  sum( is.na( cur_partition ) == FALSE )
          
          
          
        }
      }
  }
  
  
  num_off_diag_groups <- length( levels( partition ) )^2 - length( levels( partition ) )
  num_off_diag <- off_diag_new
  
  F_stat_array <- vector()
  prop_sampl_df_list <- list()

  for( ii in 1:N_sampling ){
 
    diagonal_sampling <- vec_within[!is.na(vec_within)]
    
    
    prop_sampl_df <- data.frame( N_sampling_num = rep( ii, num_off_diag_groups ), #which N_sampling is performed
                                 sampling_num = numeric( num_off_diag_groups ),#how many elements are sampled
                                 partitions = character( num_off_diag_groups ),# for what between group partition the sampling is performed
                                 part_mean = numeric( num_off_diag_groups ),# mean of the current between group partition
                                 prop_mean = numeric( num_off_diag_groups ),# mean of the sampled elements  
                                 sampling_ind = character( num_off_diag_groups), #indexes for the sampled elements from the vector of the whole
                                 sampled_from = character(num_off_diag_groups), 
                                 stringsAsFactors=FALSE )  
    
    non_na_vec_within <- sum( is.na( vec_within ) == FALSE )
    
    
    k <- 0
    delta_jj_prime <- vector()
    SNM_b <- 0
    SNM_b_array <- vector()
    for( i in 1:length( levels( partition ) ) ){
      for( j in 1:length( levels( partition ) ) ){
        if( i != j ){ 
          
          ind_row_partition <- which(  sub('_[^_]*$', '', colnames( partition_df ) ) == levels( partition )[i] )
          ind_col_partition <- which(  sub('_[^_]*$', '', colnames( partition_df ) ) == levels( partition )[j] )
          cur_partition <-  as.numeric( as.matrix( partition_df[ ind_row_partition, ind_col_partition ] ) )
          non_na_cur_partition <-  sum( is.na( cur_partition ) == FALSE )
          delta_jj_prime <- mean( cur_partition,  na.rm = TRUE )
           
          prop_num <- floor( non_na_cur_partition  *  non_na_vec_within  / as.numeric( num_off_diag )  ) 
    
          if( prop_num == 0 ){
            print( 'prop_num = 0 -> changed to 1' )
            prop_num <- 1 }
        
          sample_ind <- sample( c( 1:length( diagonal_sampling ) ), prop_num, replace = FALSE )
          k <- k + 1
          prop_sampl_df$sampling_num[k] <- prop_num
          prop_sampl_df$partitions[k] <- paste0( levels( partition )[i], ',', levels( partition )[j] )
          prop_sampl_df$sampling_ind[k] <- paste0( sample_ind, collapse = ',' )
          prop_sampl_df$sampled_from[k] <- paste0( round( diagonal_sampling, 3) , collapse = ',' )
          delta_prop <- mean( diagonal_sampling[ sample_ind ],  na.rm = TRUE )
          
    
          if( floor( non_na_cur_partition  *  non_na_vec_within  / as.numeric( num_off_diag )  )  != 0 ){ diagonal_sampling <- diagonal_sampling[ -sample_ind ] }
          prop_sampl_df$prop_mean[k] <- delta_prop
          
          
          delta_jj_prime <- mean( cur_partition,  na.rm = TRUE )
               
          prop_sampl_df$part_mean[k] <- delta_jj_prime
          SNM_b <- SNM_b + ( ( delta_jj_prime - delta_prop )/( sqrt( ( 1/( non_na_cur_partition ) + 1/prop_num ) ) ) )^2
          
        }
      }
    }
    
    #calculate statistics
    prop_sampl_df_list[[ii]] <- prop_sampl_df 
    SNM_b_array[ii] <- SNM_b
    F_stat_array[ii] <- ( SNM_b/length( levels( partition ) ) ) / SNM_w
    
  }
  
  
  
  F_stat <- mean( F_stat_array, na.rm = TRUE )
  
  df1 <- length( levels( partition ) )^2 - length( levels( partition ) )
  df2 <-  length( levels( partition ) ) - 1
  p_value <- pf( F_stat, df1, df2, lower.tail = F ) 
  partition_df1 <- partition_df

  
  res <- list()
  
  res[[1]] <- data.frame( N_partitions = length( levels( partition ) ), partition = paste(  levels( partition ) , collapse = ','), n_partition = paste( n_partition , collapse= ','  ), delta_w = delta_w,  delta_jj = paste( delta_jj, collapse= ',' ),  SNM_w = SNM_w,  SNM_b = mean( SNM_b_array, na.rm = TRUE ), F_stat =  F_stat, p_value = p_value  )
  
  res[[2]] <- do.call( rbind.data.frame, prop_sampl_df_list )
 
  names( res ) <- c( 'summary', 'proportional_sampling' ) 
  
  res
  
}





#functions needed to perform simulations with different distributions and group sizes

#generate datasets based on selection
generate_diss <- function( distribution, group_N, df_dist_par, show_plots ){
  
  if ( distribution == 'uniform' ) {
      
      dist_function <- function( N, par1, par2 ){
        r <- runif( N, par1, par2 )
        r
      } 
    }
    
  if ( distribution == 'normal' ) {
      
      dist_function <- function( N, mean, sd ){
        r <- rnorm( N, mean, sd )
        r
      } 
    }
  
  if ( distribution == 'gamma' ) {
      
      dist_function <- function( N, shape, rate ){
        r <- rnorm( N, shape, rate )
        r
      } 
    }
    
  if ( distribution == 'chisq' ) {
      
      dist_function <- function( N, df, ignored ){
        r <- rchisq( N, df )
        r
      } 
    }
  
    block_list <- list()
    block_list_row <- list()
    k <- 0
    l <- 0
    for ( i in 1:length( group_N ) ){
      l <- l + 1
      for ( j in 1:length( group_N ) ){
        k <- k + 1
        ind <- which( df_dist_par$groups == paste0( 'group', i, ',', 'group', j ) )
        par <- as.numeric( unlist( strsplit( df_dist_par$dist_par[ind], split=',', fixed=TRUE ) ) )
        block_list[[k]] <- matrix( dist_function( group_N[i]*group_N[j], par[1], par[2] ), ncol = group_N[j] )
        
        
      }
      
      r <- block_list[[1]]
      
      for( m in 2:length( group_N ) ){
         r <- cbind( r, block_list[[m]])
        
      }
      
     block_list_row[[l]] <- r
     k <- 0
      
    }
    
    r <- block_list_row[[1]]
    for( m in 2:length( group_N ) ){
         r <- rbind( r, block_list_row[[m]])
        
    }
    
    if( show_plots == TRUE) { 
      pheatmap(r, cluster_rows = F, cluster_cols = F )
      #pheatmap(r )
      }
    
    r
    
}
nmANOVA_sim <- function( distribution, group_N, par_vec, H1_group = NULL, show_plots = FALSE, N_sampling = 10  ){
  
  
        
      par1 <- par_vec[1]
      par2 <- par_vec[2]
      
      df_dist_par <- data.frame( groups = character( length( group_N )^2 ), 
                                 dist_par = character( length( group_N )^2 ), 
                                 stringsAsFactors=FALSE )
      k <- 0
      for ( i in 1:length( group_N ) ){
      for ( j in 1:length( group_N ) ){
          
          k <- k + 1 
          df_dist_par$groups[k] <- paste0( 'group', i, ',', 'group', j )
          
      if( ( !is.null( H1_group ) ) & ( length( which( H1_group$groups ==  df_dist_par$groups[k] ) ) != 0 )  ){
        
        par1_new <- H1_group$dist_par1[ which( H1_group$groups ==  df_dist_par$groups[k] )]
        par2_new <- H1_group$dist_par2[ which( H1_group$groups ==  df_dist_par$groups[k] )]
        df_dist_par$dist_par[k] <- paste0( par1_new,',', par2_new )
        
      } else{
         df_dist_par$dist_par[k] <- paste0( par1,',', par2 )
      }  
          
         
          
        }
        
      }
      
      
      #generate datasets based on selection
      diss_data <- generate_diss( distribution, group_N, df_dist_par, show_plots )
     
      partition <- vector()
      for( i in 1:length( group_N ) ){
        partition <- c( partition, rep( paste0( 'group', i ), group_N[i] ) )
        
      }
    # N_sampling <- 10
      res <-list( nmANOVA( diss_data, partition, N_sampling ), diss_data )
                  
      res
      
      
}


```

function that makes N iterations of N_part partitions and gives back the nmAnova p-values
```{r}

random_part <- function( diss_data, N_part=2, N_sampling = 1, iter = 1000 ){
  
  g <- split( 1:nrow( diss_data ),  sample( N_part, nrow( diss_data ) , repl = TRUE ) )
  
  partition <- c( rep( 'partition1', nrow( diss_data ) ) )
  
  for( i in 1:length( g ) ){
   partition[ g[[i]] ]  <- paste( 'partition', i, sep ='' )
    
    
  } 
  
  
} 




#P-VALUE ABC FIGURE
#Figure 1
#5 files you need for code execution: 1_prop_1000_p_valuesh0.RData, unfix_seed_1000_prop_1000_delta_p_values.RData, #fix_seed_1000_prop_1000_delta_p_values.RData, 
#sd_unfix_seed_1000_prop_1000_delta_p_values.RData, sd_fix_seed_1000_prop_1000_delta_p_values.RData
#you can modify the manuscript Figure 1 using Inkscape, file ABC2.svg


# A: part with ks.test results


load("1_prop_1000_p_valuesh0.RData")
 
df <- data.frame( x = p_value_h0 )
ks.test( p_value_h0, "punif", 0, 1 )

ggplot(df, aes(x=x))+
  geom_histogram(color="black", fill="lightblue", alpha = 0.6, bins = 50) + theme_bw()  + xlab( 'p-value' ) + ylab( "Count" ) + theme(plot.title = element_text(size = 25),axis.text.x = element_text(angle = 0, hjust = 1, size = 25), axis.title=element_text(size=25), axis.text.y = element_text(angle = 0, hjust = 1, size = 25), legend.title=element_text(size=25), legend.text=element_text(size=25) )  + theme(legend.position = "none") +  annotate("text", x=0.52, y=31, label= expression( paste( italic( "Kolmogorov-Smirnov test p-value = 0.5074" )  ) ), size = 7) 



# B: part with mean change only

load("unfix_seed_1000_prop_1000_delta_p_values.RData")
p_value_unfix <- p_value

load("fix_seed_1000_prop_1000_delta_p_values.RData")
delta <- seq( 0, 10, length.out = 1000 )

df <- data.frame( delta = rep( delta, 3 ), num = c( seq(1,1000, length.out = 1000), seq( 1100,2100, length.out = 1000),seq( 2200,3200, length.out = 1000) ) ,  group_num = c( rep( 1, 1000 ), rep( 2, 1000 ), rep( 3, 1000 ) ),  x = p_value )

df2 <- data.frame( delta = rep( delta, 3 ), num = c( seq(1,1000, length.out = 1000), seq( 1100,2100, length.out = 1000),seq( 2200,3200, length.out = 1000) ) ,  group_num = c( rep( 1, 1000 ), rep( 2, 1000 ), rep( 3, 1000 ) ),  x = p_value_unfix )

s <- 
  df %>%
  group_by( group_num ) %>%
  dplyr::summarise( mean = mean(x), median = median( x))
#f <- glm( x ~ num, data = df[1:1000,])
#summary(f)
#plot(f)


ggplot( df, aes( x =  num, y = ( log(x) ) ) ) +  
  
   geom_point( data = df2, aes( x =  num, y = ( log(x) ) ),  alpha = 0.05, size = 4, col = 'red')  +#xlim( -0.007, 0.01) + ylim( -0.005, 0.005 
   geom_line( alpha = 0.7,  size = 2, col = 'blue')  +#xlim( -0.007, 0.01) + ylim( -0.005, 0.005 ) +
#geom_point( alpha = 0.5, size = 3, col = 'red')  +#xlim( -0.007, 0.01) + ylim( -0.005, 0.005 ) +
   
  geom_segment( aes(x = 1, xend=200,  y = log( s$mean[1])), yend=log( s$mean[1]), size = 1) +
  geom_segment( aes(x = 1100, xend=1300,  y = log( s$mean[2])), yend=log( s$mean[2]), size = 1) +
  geom_segment( aes(x = 2200, xend=2400,  y = log( s$mean[3])), yend=log( s$mean[3]), size = 1) +
  
   geom_segment( aes(x = 400, xend=600,  y = log( s$median[1])), yend=log( s$median[1]), size = 1) +
  geom_segment( aes(x = 1500, xend=1700,  y = log( s$median[2])), yend=log( s$median[2]), size = 1) +
  geom_segment( aes(x = 2600, xend=2800,  y = log( s$median[3])), yend=log( s$median[3]), size = 1) +
  
scale_x_continuous(breaks=c(1, 1000, 1100, 2100, 2200,3200) ,
        labels=c("1",'10',  "1", "10", '1', '10')) +
  
  
  #geom_line( data = df2, aes( x =  num, y = ( log(x) ) ), alpha = 0.2,  size = 2, col = 'blue')  + #xlim( -0.007, 0.01) + ylim( -0.005, 0.005 ) + 
 
            theme(panel.grid.minor = element_line(colour = "grey", size = 0.1), 
              panel.grid.major = element_line(colour = "grey", size = 0.5)) +
             theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
             theme_bw()+ xlab( expression(delta) ) + ylab( "log(p-value)" ) +  theme(plot.title = element_text(size = 25),axis.text.x = element_text(angle = 0, hjust = 1, size = 25), axis.title=element_text(size=25), axis.text.y = element_text(angle = 0, hjust = 1, size = 25), legend.title=element_text(size=25), legend.text=element_text(size=25) )  + theme(legend.position = "none")





# C: part with sd change only

load("sd_unfix_seed_1000_prop_1000_delta_p_values.RData")
p_value_unfix <- p_value

load("sd_fix_seed_1000_prop_1000_delta_p_values.RData")

df <- data.frame( delta = rep( delta, 3 ), num = c( seq(1,1000, length.out = 1000), seq( 1100,2100, length.out = 1000),seq( 2200,3200, length.out = 1000) ) ,  group_num = c( rep( 1, 1000 ), rep( 2, 1000 ), rep( 3, 1000 ) ),  x = p_value )

df2 <- data.frame( delta = rep( delta, 3 ), num = c( seq(1,1000, length.out = 1000), seq( 1100,2100, length.out = 1000),seq( 2200,3200, length.out = 1000) ) ,  group_num = c( rep( 1, 1000 ), rep( 2, 1000 ), rep( 3, 1000 ) ),  x = p_value_unfix )

s <- 
  df %>%
  group_by( group_num ) %>%
  dplyr::summarise( mean = mean(x), median = median( x))
#f <- glm( x ~ num, data = df[1:1000,])
#summary(f)
#plot(f)


ggplot( df, aes( x =  num, y = ( log(x) ) ) ) +  
  
   geom_point( data = df2, aes( x =  num, y = log( (x) ) ),  alpha = 0.05, size = 4, col = 'red')  +#xlim( -0.007, 0.01) + ylim( -0.005, 0.005 
   geom_line( alpha = 0.7,  size = 2, col = 'blue')  +#xlim( -0.007, 0.01) + ylim( -0.005, 0.005 ) +
#geom_point( alpha = 0.5, size = 3, col = 'red')  +#xlim( -0.007, 0.01) + ylim( -0.005, 0.005 ) +
   
  geom_segment( aes(x = 200, xend=400,  y = log( s$mean[1])), yend=log( s$mean[1]), size = 1) +
  geom_segment( aes(x = 1300, xend=1500,  y = log( s$mean[2])), yend=log( s$mean[2]), size = 1) +
  geom_segment( aes(x = 2400, xend=2600,  y = log( s$mean[3])), yend=log( s$mean[3]), size = 1) +
  
   geom_segment( aes(x = 400, xend=600,  y = log( s$median[1])), yend=log( s$median[1]), size = 1) +
  geom_segment( aes(x = 1500, xend=1700,  y = log( s$median[2])), yend=log( s$median[2]), size = 1) +
  geom_segment( aes(x = 2600, xend=2800,  y = log( s$median[3])), yend=log( s$median[3]), size = 1) +
  
scale_x_continuous(breaks=c(1, 1000, 1100, 2100, 2200,3200) ,
        labels=c("1",'10',  "1", "10", '1', '10')) +
 # scale_y_continuous(breaks=c(1,0.8, 0.6, 0.4, 0.2,0.1) ) +
  
  
  #geom_line( data = df2, aes( x =  num, y = ( log(x) ) ), alpha = 0.2,  size = 2, col = 'blue')  + #xlim( -0.007, 0.01) + ylim( -0.005, 0.005 ) + 
 
            theme(panel.grid.minor = element_line(colour = "grey", size = 0.1), 
              panel.grid.major = element_line(colour = "grey", size = 0.5)) +
             theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
             theme_bw()+ xlab( expression(delta) ) + ylab( "log( p-value )" ) +  theme(plot.title = element_text(size = 25),axis.text.x = element_text(angle = 0, hjust = 1, size = 25), axis.title=element_text(size=25), axis.text.y = element_text(angle = 0, hjust = 1, size = 25), legend.title=element_text(size=25), legend.text=element_text(size=25) )  + theme(legend.position = "none")


#ASYMPTOTIC P-VALUES   
#Figure 2 
#p-values were collected at csc and saved in mil_df2.RData 


library( ggplot2 )

#2 mil p-value dataframe
load("mil_df2.RData")

# initial matrix for the figure
load("mil_diss_mat_prop_sampl_df2.RData")
m <- mean( ( df$p_value ) )
df2 <- df[c(50:2000000),]
#df2 <- df

scientific_10 <- function(x) {
  parse(text=gsub("e", " %*% 10^", scales::scientific_format()(x)))
}


ggplot(df2, aes(x=log10( prop_sampl_num ), y=( -log10( p_value ) )))+ 
  geom_line()+# ylim( 5.931020e-05, 5.9345e-05) + #xlim(-50 ,320 )+
  #geom_point(col = 'red', size = 0.1)+
  scale_x_continuous(breaks=c( log10( 50 ), log10( 10000),  log10( 100000), log10( 500000 ),    log10( 2000000 ) ),
        labels= scientific_10( c( 50, 10000, 100000,  500000, 2000000 ) ) ) +
  #scale_y_continuous(label=scientific_10) +
  geom_hline( yintercept = -log10( mean( ( df$p_value ) ) ), col = 'red' ) +
             theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1) ) +
              xlab( "Number of proportional samplings performed" ) + ylab( "-log10(p-value)" ) + 
                theme(plot.title = element_text(size = 25),axis.text.x = element_text(angle = 0, hjust = 1, size = 20), axis.title=element_text(size=25), axis.text.y = element_text(angle = 0, hjust = 1, size = 25), legend.title=element_text(size=20), legend.text=element_text(size=20) ) 






#BLAST
#Figure 3 
#2 files are needed for code execution: filt_species.xlsx, allvall.txt. allvall.txt was given by Ali, colnames are missing
#1 file with final selected blasts for plot (our blast table in the manuscript have those): blast_data.xlsx

filt_sp <- read.xlsx( "filt_species.xlsx" )
t<- read.table("allvall.txt", header=FALSE)

M <- 
  filt_sp%>%filter( Clade == 'Monocot' )
D <- 
  filt_sp%>%filter( Clade == 'Eudicot' )
  
ind_monocot <- which( unique(t$V1) %in% M$Species)
ind_eudicot <- which( unique(t$V1) %in% D$Species)
combined<- c(ind_monocot, ind_eudicot)
all_mono <- unique(t$V1)[ind_monocot]
all_eudi <- unique(t$V1)[ind_eudicot]

partition <- c( rep( 'Monocot', length( ind_monocot ) ),rep( 'Eudicot', length( ind_eudicot ) ) )


B <- matrix(0,length( combined ), length( combined ))
E <- matrix(0,length( combined ),length( combined ))

for (i in 1:length( combined )){
  
  tt<-subset(t, t$V1==(unique(t$V1)[combined])[i])#filtering is based on the first column
  
  for (j in 1:length( combined ) ) {
    
    B[i,j]<- subset(tt, tt$V2==(unique(t$V1)[combined])[j])[1,12]#the first row (highest E-value and Bitscore) and its bit score
    
    E[i,j]<- subset(tt, tt$V2==(unique(t$V1)[combined])[j])[1,11]
  }
}

#DeltaB<- 1/( -log( E ) )^2


DeltaB <- ( 1/B) # not symmetric - I checked but most of the values are symmetric
colnames( DeltaB ) <- c( paste( "Monocot", seq( 1:length( ind_monocot ) ), sep = '_' ), paste( "Eudicot", seq( 1:length( ind_eudicot ) ), sep = '_' ) )
rownames( DeltaB ) <- colnames( DeltaB )

DD <- DeltaB
res2 <- nmANOVA(DeltaB, partition, N_sampling = 10 )
M <- as.vector( DeltaB[1:length( ind_monocot), 1:length( ind_monocot)] ) 
E <-  as.vector( DeltaB[( length( ind_monocot) +1 ):nrow( DeltaB ), ( length( ind_monocot) +1 ):nrow( DeltaB ) ] )

all_mono <- unique(t$V1)[ind_monocot]
all_eudi <- unique(t$V1)[ind_eudicot]

#lets make it more significant via removing outliers and creating more distinct clusters 
excl_mono <- paste( 'Monocot', c( 7, 23, 21, 17, 8, 9  ), sep = '_' )
ind_excl_mono <-  which( colnames( DeltaB ) %in% excl_mono  )
all_mono2 <- all_mono[-c( 7, 23, 21, 17, 8, 9  )]
d <-DeltaB[-ind_excl_mono, -ind_excl_mono]
partition <- sub('_[^_]*$', '', colnames( d  ) ) 


exc_dico <- paste(  "Eudicot", c(   11, 39, 47, 59, 56, 24 ,58, 21, 28, 23, 70 , 57, 63, 71, 37, 15, 68, 69, 36 ), sep = '_' ) 
ind_excl_dico <-  which( colnames( d ) %in% exc_dico  )
all_eudi2 <- all_eudi[-c(   11, 39, 47, 59, 56, 24 ,58, 21, 28, 23, 70 , 57, 63, 71, 37, 15, 68, 69, 36 )]
d<- d[ -ind_excl_dico, -ind_excl_dico]
 partition <- sub('_[^_]*$', '', colnames( d  ) ) 
res <- nmANOVA( d , partition, N_sampling = 10 ) 
res$summary$p_value#p_value = 0.044



m2 <- matrix(NA, ncol = ncol(d), nrow = nrow(d))
m2[upper.tri(m2)] <- rowMeans(cbind(d[upper.tri(d, diag = FALSE)], 
                                d[lower.tri(d, diag = FALSE)]))
m2[lower.tri(m2)] <- rowMeans(cbind(d[upper.tri(d, diag = FALSE)], 
                                d[lower.tri(d, diag = FALSE)]))
diag(m2 ) <- diag( d)
colnames( m2 )<- colnames(d)
rownames( m2 )<- rownames(d)


mds.coor=cmdscale( as.dist( ( m2 ) ) )
mds.coor <- as.data.frame( mds.coor)
colnames( mds.coor ) <- c( 'coor1', 'coor2' )
mds.coor <- 
  mds.coor %>%
  mutate( Species =  sub('_[^_]*$', '', rownames( mds.coor ) ) )


#### plot for the paper 
 ggplot( mds.coor, aes( x =  ( coor1 ), y = ( coor2 ), shape = as.factor( Species ), col = as.factor( Species ) ) ) +  
   geom_point( alpha = 0.7,  size = 10)  +#xlim( -0.007, 0.01) + ylim( -0.005, 0.005 ) +

            theme(panel.grid.minor = element_line(colour = "grey", size = 0.1), 
              panel.grid.major = element_line(colour = "grey", size = 0.5)) +
             theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1))  +
             theme_bw()+ xlab( "MDS coordinate 1 " ) + ylab("MDS coordinate 2" ) +
                theme(plot.title = element_text(size = 25),axis.text.x = element_text(angle = 0, hjust = 1, size = 25), axis.title=element_text(size=28), axis.text.y = element_text(angle = 0, hjust = 1, size =25), legend.title=element_text(size=28), legend.text=element_text(size=28) ) + annotate("text", x=0.0010, y=0.0033, label= expression( paste( italic( "p-value = 0.044" )  ) ), size = 10) +  #+ geom_text( aes( label = rownames( mds.coor ) ), size = 4, hjust=0, vjust = 1 ) #+ theme(legend.position = "none")
  guides( col=guide_legend(title="Species"), shape = guide_legend(title='Species'))
 
expression( paste(italic( 'drm()' ), " elapsed time (", italic(s), ')') )



#check of the dataset 
sel_species <- c( all_mono2, all_eudi2 )

t2 <- 
  t %>%
  filter( V1 %in% sel_species )%>%
  filter( V2 %in% sel_species )

  
M <- 
  filt_sp%>%filter( Clade == 'Monocot' )
D <- 
  filt_sp%>%filter( Clade == 'Eudicot' )

ind_monocot <- which( unique(t2$V1) %in% M$Species)
ind_eudicot <- which( unique(t2$V1) %in% D$Species)

combined<- c(ind_monocot, ind_eudicot)
all_mono <- unique(t2$V1)[ind_monocot]
all_eudi <- unique(t2$V1)[ind_eudicot]

partition <- c( rep( 'Monocot', length( ind_monocot ) ),rep( 'Eudicot', length( ind_eudicot ) ) )


B <- matrix(0,length( combined ), length( combined ))
E <- matrix(0,length( combined ),length( combined ))

for (i in 1:length( combined )){
  
  tt<-subset(t2, t2$V1==(unique(t2$V1)[combined])[i])#filtering is based on the first column
  
  for (j in 1:length( combined ) ) {
    
    B[i,j]<- subset(tt, tt$V2==(unique(t2$V1)[combined])[j])[1,12]#the first row (highest E-value and Bitscore) and its bit score
    
    E[i,j]<- subset(tt, tt$V2==(unique(t2$V1)[combined])[j])[1,11]
  }
}

#DeltaB<- 1/( -log( E ) )^2


DeltaB <- ( 1/B) # not symmetric - I checked but most of the values are symmetric
colnames( DeltaB ) <- c( paste( "Monocot", seq( 1:length( ind_monocot ) ), sep = '_' ), paste( "Eudicot", seq( 1:length( ind_eudicot ) ), sep = '_' ) )
rownames( DeltaB ) <- colnames( DeltaB )
  res_check <- nmANOVA(DeltaB, partition, N_sampling = 10 ) # exactly same - so save t2
  res_check$summary$p_value#p_value = 0.044
#write.xlsx(t2, file = 'blast_data.xlsx')




#KL BLADDER DATASET
#Table 6, Figure 9 (Supplementary) and Figure 4
#you have to load library bladderbatch and bladderKL_JT.RData with precalculated KL values
#p-values for table are in nm_df dataframe

library(bladderbatch)
library( ggplot2)
data( bladderdata )

pheno <- pData(bladderEset)
#samples_cancer <- rownames( pheno[ which( pheno$cancer == 'Cancer'), ] )

edata <- exprs(bladderEset)

#now load Kullback Leibler divergence matrix
load("bladderKL_JT.RData")
bl <- bladderKL
colnames( bl )[18:29] <- paste( 'mTCC', seq(1:12), sep = '_' )
colnames( bl )[30:41] <- paste( 'sTCC+CIS', seq(1:12), sep = '_' )
colnames( bl )[42:57] <- paste( 'sTCC-CIS', seq(1:16), sep = '_' )

#colnames( bl ) <- sub('_[^_]*$', '', colnames( bl ))
#rownames( bl ) <- colnames( bl )

#for heatmap
pheatmap( log( bl + 0.01), labels_row = sub('_[^_]*$', '', colnames( bl )), labels_col =  sub('_[^_]*$', '', colnames( bl )), fontsize_row = 12, fontsize_col = 13 )

#classical multidimensional scaling based on KL
d <- as.dist(bladderKL)
mds.coor <- cmdscale(d)
plot(mds.coor[,1], mds.coor[,2], type="n", xlab="", ylab="")
text(jitter(mds.coor[,1]), jitter(mds.coor[,2]),
     rownames(mds.coor), cex=1.2)
abline(h=0,v=0,col="gray75")
df.dist=as.matrix(d, labels=TRUE)





#for PCA
prc <- prcomp( t( edata ), center = T, scale = T )
prc_res <- as.data.frame( prc$x )
prc_res <- merge( prc_res, pheno, by = 'row.names' )

#PCA plot
ggplot( prc_res , aes( x =  PC1, y = PC2, col = as.factor( outcome ) ) ) + geom_point( size = 10, alpha = 0.7 ) +
              theme(panel.grid.minor = element_line(colour = "grey", size = 0.1), 
              panel.grid.major = element_line(colour = "grey", size = 0.5)) +
             theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
             theme_bw()+ xlab( "PC1" ) + ylab( "PC2" ) + guides(col=guide_legend(title="Sample"), shape = guide_legend(title='concentrations'))+ theme(plot.title = element_text(size = 25),axis.text.x = element_text(angle = 0, hjust = 1, size = 25), axis.title=element_text(size=25), axis.text.y = element_text(angle = 0, hjust = 1, size = 25), legend.title=element_text(size=25), legend.text=element_text(size=25) )+ annotate("text", x=-15, y=95, label= expression( paste( italic( "p-value = 0.041" )  ) ), size = 10) 


#collect results for all the partitions ijn nm_df
#change the column/row names
better_names <- c( paste0( 'Normal', '_', c( 1:8 ) ), paste0( 'Biopsy', '_', c( 1:9 ) ), paste0( 'mTCC', '_', c( 1:12 ) ), paste0( 'sTCC+CIS', '_', c( 1:12 ) ),  paste0( 'sTCC-CIS', '_', c( 1:16 ) ) ) 
colnames( bladderKL ) <- better_names
rownames( bladderKL ) <- better_names
diss_df <- bladderKL
#select partitions to be used in the paper table
partition <- list()
partition[[1]] <-c( "Normal"   ,         "Biopsy" )
partition[[2]] <-c( "Normal"   ,         "mTCC" )
partition[[3]] <-c( "Normal"   ,         "sTCC+CIS" )
partition[[4]] <-c( "Normal"   ,         "sTCC-CIS" )
partition[[5]] <-c( "Biopsy"   ,         "mTCC" )
partition[[6]] <-c( "Biopsy"   ,         "sTCC+CIS" )
partition[[7]] <-c( "Biopsy"   ,         "sTCC-CIS" )
partition[[8]] <-c( "mTCC"   ,         "sTCC+CIS" )
partition[[9]] <-c( "mTCC"   ,         "sTCC-CIS" )
partition[[10]] <-c( "sTCC+CIS"   ,         "sTCC-CIS" )

partition[[11]] <- c( "mTCC"  ,     "sTCC+CIS" ,  "sTCC-CIS" )

partition[[12]] <- c( "Normal"   , "mTCC"  ,     "sTCC+CIS" ,  "sTCC-CIS"   )
partition[[13]] <- c( "Biopsy"   , "mTCC"  ,     "sTCC+CIS" ,  "sTCC-CIS"   )
partition[[14]] <- c( "Normal"   ,      "mTCC+sTCC+CIS+sTCC-CIS" ) 
partition[[15]] <- c( "Biopsy"   ,       "mTCC+sTCC+CIS+sTCC-CIS" )

partition[[16]] <- c( "Normal"   ,         "Biopsy" ,   "sTCC+CIS" )
partition[[17]] <- c( "Normal+Biopsy"   , "sTCC+CIS" )

partition[[18]] <- c( "Normal",         "Biopsy" ,   "sTCC-CIS" )
partition[[19]] <- c( "Normal+Biopsy", "sTCC-CIS" )

partition[[20]] <- c( "Normal",         "Biopsy" ,   "mTCC" )
partition[[21]] <- c( "Normal+Biopsy", "mTCC" )


partition[[22]] <- c( "Normal+Biopsy"  , "mTCC"  ,     "sTCC+CIS" ,  "sTCC-CIS" )
partition[[23]] <- c( "Normal+Biopsy"  ,"mTCC+sTCC+CIS+sTCC-CIS" )

partition[[24]] <- c( "Biopsy"   ,"Normal", "mTCC"  ,     "sTCC+CIS" ,  "sTCC-CIS"   )



d <- as.matrix( diss_df )


joints <- c( "Normal+Biopsy", "mTCC+sTCC+CIS+sTCC-CIS" )
ind_Norm_Biopsy <-  which( sub('_[^_]*$', '', colnames( d ) ) %in% c( 'Normal', 'Biopsy' ) )
ind_Cancers <-  which( sub('_[^_]*$', '', colnames( d ) ) %in% c( "mTCC"  ,     "sTCC+CIS" ,  "sTCC-CIS" ) )


#nmANOVA 
res_m <- list()
res_dist <- list()
pca_plot <- list()
ggplot_list <- list()


for( i in 1:length( partition ) ){
  
  if( length( intersect( partition[[i]], joints ) ) > 0 ){
    
    sel_partition <- c( rep('Normal', 8), rep('Biopsy', 9), rep("mTCC" , 12 ), rep("sTCC+CIS" , 12 ), rep("sTCC-CIS" , 16 ) )
    l <- unique( partition[[i]] )
    sub1 <- vector()
    sub2 <- vector()
    if( "Normal+Biopsy" %in% l )  { 
      sel_partition[ ind_Norm_Biopsy ] <- 'Normal+Biopsy' 
      sub1 <- union( l, c( 'Normal', 'Biopsy') )
    }
    if( "mTCC+sTCC+CIS+sTCC-CIS" %in% l )  { 
      sel_partition[ ind_Cancers ] <- "mTCC+sTCC+CIS+sTCC-CIS" 
      sub2 <- union( l, c( 'mTCC', 'sTCC+CIS', 'sTCC-CIS') )
      }
    
    sub <- union( sub1 , sub2 )
    subpartition <- partition[[i]]
    res_m[[i]] <- nmANOVA(d, sel_partition,  10,  subpartition )
    res_m[[i]] <- res_m[[i]]$summary
    
    
   
    ind <- which( sub('_[^_]*$', '', colnames( d  ) ) %in%  sub )
     dd <- as.dist( d[ind, ind] )
      mds.coor <- cmdscale(dd)
      
      mds.coor <- as.data.frame( mds.coor)
      colnames( mds.coor ) <- c( 'coor1', 'coor2' )
      mds.coor <- 
        mds.coor %>%
        mutate( Sample =  sub('_[^_]*$', '', rownames( mds.coor ) ) )
      
      
      if( "Normal+Biopsy" %in% l ) { 
        ind <- which(mds.coor$Sample %in% c( 'Normal', 'Biopsy' ) )
        mds.coor$Sample[ind] <-  "Normal+Biopsy"
        
      }
      
      if( "mTCC+sTCC+CIS+sTCC-CIS" %in% l )  { 
      
       ind <- which(mds.coor$Sample %in%  c( 'mTCC', 'sTCC+CIS', 'sTCC-CIS') )
        mds.coor$Sample[ind] <-"mTCC+sTCC+CIS+sTCC-CIS" 
       
        
       
      }
      
      
       ggplot_list[[i]] <- ggplot( mds.coor, aes( x =  ( coor1 ), y = ( coor2 ), col = as.factor( Sample )  ) )  + xlim( -0.3, 0.3) +ylim( -0.05, 0.05 ) + 
         geom_point( alpha = 0.7,  size = 7)  +#xlim( -0.007, 0.01) + ylim( -0.005, 0.005 ) +
      
                  theme(panel.grid.minor = element_line(colour = "grey", size = 0.1), 
                    panel.grid.major = element_line(colour = "grey", size = 0.5)) + ggtitle( paste('p-value = ', round( res_m[[i]]$p_value, 4 ) )) +
                   theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1))  +
                   theme_bw()+ xlab( "mds.coor1" ) + ylab( "mds.coor2" ) +
                      theme(plot.title = element_text(size = 15),axis.text.x = element_text(angle = 0, hjust = 1, size = 10), axis.title=element_text(size=10), axis.text.y = element_text(angle = 0, hjust = 1, size =10), legend.title=element_text(size=10), legend.text=element_text(size= 10) ) #+ geom_text( aes( label = rownames( mds.coor ) ), size = 4, hjust=0, vjust = 1 ) #+ theme(legend.position = "none")
      
          
          pheno2 <- 
            pheno %>%
            filter( outcome %in%  sub )
          ind <- which( colnames( edata ) %in% rownames( pheno2 ) )
          edata2 <- edata[, ind]
            
          prc <- prcomp( t( edata2 ), center = T, scale = T )
      
          prc_res <- as.data.frame( prc$x )
          prc_res <- merge( prc_res, pheno2, by = 'row.names' )
          prc_res$outcome <- as.character(prc_res$outcome  )
       if( "Normal+Biopsy" %in% l ) { 
        ind <- which(prc_res$outcome %in% c( 'Normal', 'Biopsy' ) )
        prc_res$outcome[ind] <-  "Normal+Biopsy"
    }
       
      if( "mTCC+sTCC+CIS+sTCC-CIS" %in% l )  { 
      
       ind <- which(prc_res$outcome %in%  c( 'mTCC', 'sTCC+CIS', 'sTCC-CIS') )
        prc_res$outcome[ind] <- "mTCC+sTCC+CIS+sTCC-CIS" 
      
       
      }
      
      
          
          
          #PCA plot
          pca_plot[[i]] <- ggplot( prc_res , aes( x =  PC1, y = PC2, col = as.factor( outcome ) ) ) + geom_point( size = 7, alpha = 0.7 ) +
                        theme(panel.grid.minor = element_line(colour = "grey", size = 0.1), 
                        panel.grid.major = element_line(colour = "grey", size = 0.5)) +ggtitle( paste('p-value = ', round( res_m[[i]]$p_value, 4 ) ) )+
                       theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
                       theme_bw()+ xlab( "PC1" ) + ylab( "PC2" ) + guides(col=guide_legend(title="dataset"), shape = guide_legend(title='concentrations'))+ theme(plot.title = element_text(size = 25),axis.text.x = element_text(angle = 0, hjust = 1, size = 25), axis.title=element_text(size=25), axis.text.y = element_text(angle = 0, hjust = 1, size = 25), legend.title=element_text(size=25), legend.text=element_text(size=25) )

    
    
    
    
  } 
  else{
    
    sel_partition <- c( rep('Normal', 8), rep('Biopsy', 9), rep("mTCC" , 12 ), rep("sTCC+CIS" , 12 ), rep("sTCC-CIS" , 16 ) )
    subpartition <- partition[[i]]
    res_m[[i]] <- nmANOVA(d, sel_partition, 10, subpartition )
   res_m[[i]] <- res_m[[i]]$summary
  
    ind <- which( sub('_[^_]*$', '', colnames( d  ) ) %in%  subpartition )
     dd <- as.dist( d[ind, ind] )
      mds.coor <- cmdscale(dd)
      
      mds.coor <- as.data.frame( mds.coor)
      colnames( mds.coor ) <- c( 'coor1', 'coor2' )
      mds.coor <- 
        mds.coor %>%
        mutate( Sample =  sub('_[^_]*$', '', rownames( mds.coor ) ) )
      
       ggplot_list[[i]] <- ggplot( mds.coor, aes( x =  ( coor1 ), y = ( coor2 ), col = Sample  ) )  + xlim( -0.3, 0.3) +ylim( -0.05, 0.05 ) + 
         geom_point( alpha = 0.7,  size = 7)  +#xlim( -0.007, 0.01) + ylim( -0.005, 0.005 ) +
      
                  theme(panel.grid.minor = element_line(colour = "grey", size = 0.1), 
                    panel.grid.major = element_line(colour = "grey", size = 0.5)) +ggtitle( paste('p-value = ', round( res_m[[i]]$p_value, 4 )  ))+
                   theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1))  +
                   theme_bw()+ xlab( "mds.coor1" ) + ylab( "mds.coor2" ) +
                      theme(plot.title = element_text(size = 15),axis.text.x = element_text(angle = 0, hjust = 1, size = 10), axis.title=element_text(size=10), axis.text.y = element_text(angle = 0, hjust = 1, size =10), legend.title=element_text(size=10), legend.text=element_text(size=10) ) #+ geom_text( aes( label = rownames( mds.coor ) ), size = 4, hjust=0, vjust = 1 ) #+ theme(legend.position = "none")
      
          
          pheno2 <- 
            pheno %>%
            filter( outcome %in%  subpartition )
          ind <- which( colnames( edata ) %in% rownames( pheno2 ) )
          edata2 <- edata[, ind]
            
          prc <- prcomp( t( edata2 ), center = T, scale = T )
          sum( colnames( edata2 ) == rownames( pheno2 ) )
          prc_res <- as.data.frame( prc$x )
          prc_res <- merge( prc_res, pheno2, by = 'row.names' )
          
          #PCA plot
          pca_plot[[i]] <- ggplot( prc_res , aes( x =  PC1, y = PC2, col = as.factor( outcome ) ) ) + geom_point( size = 7, alpha = 0.7 ) + ylim( -0.2, 0.2) +xlim( -0.03, 0.03 ) +
                        theme(panel.grid.minor = element_line(colour = "grey", size = 0.1), 
                        panel.grid.major = element_line(colour = "grey", size = 0.5)) +ggtitle( paste('p-value = ', round( res_m[[i]]$p_value, 4 ) ) )+
                       theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
                       theme_bw()+ xlab( "PC1" ) + ylab( "PC2" ) + guides(col=guide_legend(title="Sample"), shape = guide_legend(title='concentrations'))+ theme(plot.title = element_text(size = 15),axis.text.x = element_text(angle = 0, hjust = 1, size = 15), axis.title=element_text(size=15), axis.text.y = element_text(angle = 0, hjust = 1, size = 15), legend.title=element_text(size=15), legend.text=element_text(size=15) )

    
    
    
  }
  
  
}  

i = 24
plot( pca_plot[[i]] )
plot( ggplot_list[[i]] )


nm_df <- 
  plyr::ldply( lapply( res_m, as.data.frame ) )


#BEST CLUSTERING
#Figure 5 (Supplementary)
#results were collected at csc and saved in 'clust' folder and par_set.RData
#you can modify the manuscript Figure using Inkscape, file ribbon_plot.svg


multiplot_list <- function( plotlist, cols) {
    require(grid)

    # Make a list from the ... arguments and plotlist
    plots <-plotlist

    numPlots = length(plots)

    # Make the panel
    plotCols = cols                          # Number of columns of plots
    plotRows = ceiling(numPlots/plotCols) # Number of rows needed, calculated from # of cols

    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(plotRows, plotCols)))
    vplayout <- function(x, y)
        viewport(layout.pos.row = x, layout.pos.col = y)

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
        curRow = ceiling(i/plotCols)
        curCol = (i-1) %% plotCols + 1
        print(plots[[i]], vp = vplayout(curRow, curCol ))
    }

}


library( stringr )
library( dplyr )
library( plyr )
library(ggplot2)

load("par_set.RData")

#here put the path to the clust folder
setwd( '~/Desktop/nmANOVA/clust' )
file_names <- as.list( dir( pattern="200N*" ) )

par_set  <- 
  par_set %>%
  mutate( num = seq( 1:nrow( par_set ) ) )

par_set$num <- as.character( par_set$num )
par_set  <-  
  par_set %>%
  arrange( num )


res <- list()

for( i in 1:length( file_names ) ) {
  
  load( file_names[[i]] ) 
  res[[i]] <- df
  
  ind <- which( par_set$num == sub("\\.RData.*", "",  sub('.*\\_', '',file_names[[i]] ) ) )
  res[[i]] <- 
    res[[i]] %>% 
    mutate( clust_num = par_set$part_num[ind]  ) 
  
}



df<- ldply( res, as.data.frame )
plot_list <- list()
df_list  <- list()
gg_list  <- list()

for( i in 3:5 ){
  
df2 <- 
  df %>%
  filter( clust_num == i )
  

if( i == 3 )
  partition <- c( rep( 'group_1' ,34 ), rep( 'group_2' ,34 ),  rep( 'group_3' ,55 ) )

if( i == 4 )
  partition <- c( rep( 'group_1' ,13 ), rep( 'group_2' ,21),  rep( 'group_3' ,34 ), rep( 'group_4' ,55 ) )
  #partition <- c( rep( 'group_1' ,21 ), rep( 'group_2' ,34),  rep( 'group_3' ,55 ), rep( 'group_4' ,89 ) )


if( i == 5 )
  partition <- c( rep( 'group_1', 13 ), rep( 'group_2' ,21 ), rep( 'group_3' ,34),  rep( 'group_4' ,21 ), rep( 'group_5' ,34 ) )


  indi <- which( ( df2$N_sampl == 0 ) &  ( df2$num_change == 0 ) )
  
  df2_null <-
    df2 %>%
    filter( N_sampl == 0, num_change == 0   )
  p_value <-  median( df2_null$p_value )

  
  print( length( unique( df2_null$part ) ) )
  
  d <- data.frame( num_change = 0, mean = ( p_value), min = (p_value ), max = (p_value), med = (p_value))

ind <- which(df2$part == paste0( partition, collapse = ',' ) )
df2 <- df2[-ind, ]


df2 <- 
  df2 %>%
  filter( N_sampl != 0, num_change != 0   )%>%
  group_by( num_change, part)%>%
  dplyr::summarise(   p_value = mean( p_value) )


 

d <- data.frame( num_change = 0, mean = ( p_value), min = (p_value ), max = (p_value), med = (p_value))

gg <- 
  df2 %>%
  group_by(num_change )%>%
  dplyr::summarise( mean = mean( p_value), min = min(p_value ), max = max(p_value), med = median(p_value) )

gg <- rbind( d, gg)

df_list[[i-1]]  <-
  df2 %>%
  mutate( clust_num =  i )

gg_list[[i-1]] <- 
  gg %>%
  mutate( clust_num =  i )  


plot_list[[i-1]]  <- ggplot( df2, aes(   x =  ( num_change ), y = (p_value ) ) ) +  
  
#geom_point( alpha = 0.3, size = 3, col = 'blue') + 
   #geom_line(data=gg)+
  # geom_ribbon(data=gg,aes(ymin=-log( min ),ymax=-log( max)),alpha=0.1) +
   geom_boxplot( aes(group = ( num_change )), col = '#3399FF', fill = '#3399FF', alpha = 0.1 )+
  geom_line(data=gg ,aes( ( num_change ), ( med )),col = 'black', size = 1, alpha = 0.7) +
  geom_point(data=gg,aes( ( num_change ), (med)),col = '#FF6666', size =2) +

 #geom_vline(xintercept =log(p_value),  
              # color = "red", size=1) +
  
 scale_x_continuous(breaks=c(0,  10,  30, 50) ,
        labels=c('0',  '10',  '30', '50' ) ) + ylim( 0,1 ) +
            theme(panel.grid.minor = element_line(colour = "grey", size = 0.1), 
              panel.grid.major = element_line(colour = "grey", size = 0.5)) +
             theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
             theme_bw()+ ylab( 'p-value' ) + xlab( "Number of pairs switched" ) +  theme(plot.title = element_text(size = 25),axis.text.x = element_text(angle = 0, hjust = 1, size = 20), axis.title=element_text(size=20), axis.text.y = element_text(angle = 0, hjust = 1, size = 20), legend.title=element_text(size=25), legend.text=element_text(size=20) )  + theme(legend.position = "none") +theme(axis.title=element_blank() )# +  annotate("text", x = 3, y = 11.5, label= expression( paste( italic( "p value for original matrix" )  ) ), size = 7
 

}




#another version of plot
df_all <- ldply( df_list, as.data.frame )
gg_all <- ldply( gg_list, as.data.frame )

df_all <- 
  df_all %>%
  mutate( hist_factor = paste( num_change, clust_num, sep = '_' ) )

 ggplot( df_all, aes(   x =  ( num_change ), y = (p_value ), col = as.factor( clust_num ) ) ) +  
  
#geom_point( alpha = 0.3, size = 3, col = 'blue') + 
   #geom_line(data=gg)+
   geom_ribbon(data=gg_all,aes(ymin=( min ),ymax= max, fill =as.factor( clust_num )) ,alpha=0.1, colour = NA ) +
 # geom_boxplot( aes(group = as.factor( hist_factor ),  fill =  as.factor( clust_num ), col = as.factor( clust_num ) ), alpha = 0.01 )+
 # geom_point(aes( group = as.factor( hist_factor ), col = as.factor( clust_num ), group = as.factor( clust_num ) ), size =1, alpha = 0.04) +
  geom_line(data=gg_all ,aes( ( num_change ), ( med ), col = as.factor( clust_num ), group = as.factor( clust_num ) ), size = 1, alpha = 0.7) +
  geom_point(data=gg_all,aes( ( num_change ), (med), col = as.factor( clust_num ), group = as.factor( clust_num ) ), size =1.4) +
  

 #geom_vline(xintercept =log(p_value),  
              # color = "red", size=1) +
  
 scale_x_continuous(breaks=c(0,  10,  30, 60 ) ,
        labels=c('0',  '10',  '30',  '60' ) ) + ylim( 0,1 ) +
            theme(panel.grid.minor = element_line(colour = "grey", size = 0.1), 
              panel.grid.major = element_line(colour = "grey", size = 0.5)) +
             theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
             theme_bw()+ ylab( 'p-value' ) + xlab( "Number of pairs switched" ) +  theme(plot.title = element_text(size = 25),axis.text.x = element_text(angle = 0, hjust = 1, size = 20), axis.title=element_text(size=20), axis.text.y = element_text(angle = 0, hjust = 1, size = 20), legend.title=element_text(size=20), legend.text=element_text(size=20) ) # + theme(legend.position = "none") #+theme(axis.title=element_blank() )# +  annotate("text", x = 3, y = 11.5, label= expression( paste( italic( "p value for original matrix" )  ) ), size = 7
 






#THREE MODELS COMPARISON
#Figure 6 (Supplementary)
#results were collected at csc and saved in 'new', 'rev_new' and 'reverse_413' folder


#######forward
setwd( 'new/')
file_names <- as.list( dir( pattern="res_413*" ) )

res <- list()

for( i in 1:length( file_names ) ) {
  
  load( file_names[[i]] ) 
  res[[i]] <- res_df
  
  
}


df<- ldply( res, as.data.frame )


df <- 
  df %>%
  dplyr::select( -m1, -m2, -m3, -m4 )%>%
  group_by( dist_method, vector_num, delta )%>%
  summarise_each( funs = mean) %>%
  ungroup()

cor( df$np_pval, df$nm_pval )
cor( df$cl_pval, df$nm_pval )
cor( df$np_pval, df$cl_pval )


df_thr <- 
  df %>%
  mutate( nm_stat_0.05 = ifelse( nm_pval <= 0.05, 'yes', 'no' ), nm_stat_0.1 = ifelse( nm_pval <= 0.1, 'yes', 'no' ),
          np_stat_0.05 = ifelse( np_pval <= 0.05, 'yes', 'no' ), np_stat_0.1 = ifelse( np_pval <= 0.1, 'yes', 'no' ),
          cl_stat_0.05 = ifelse( cl_pval <= 0.05, 'yes', 'no' ), cl_stat_0.1 = ifelse( cl_pval <= 0.1, 'yes', 'no' ) )%>%
  mutate( group = paste( dist_method, vector_num, sep = '_' ) )
  
all_groups <- unique( df_thr$group )

df_5 <- as.data.frame( matrix(0, ncol = length( all_groups ), nrow = 5 ) )
colnames( df_5 ) <- all_groups
rownames( df_5 ) <- c( 'max', 'min', 'cl', 'np', 'nm' )
df_5[1, ] <- 0
df_5[2, ] <- -2

df_1 <- df_5

for( j in 1:length( all_groups ) ){
  
  cur_df <- 
    df_thr %>%
    filter( group == all_groups[j] ) %>%
    arrange( delta )
  
  
 df_5[3,j] <- -cur_df$delta[ which( cur_df$cl_stat_0.05 == 'yes')[1] ]
 print( 'cl' ) 
 print( length( which( cur_df$cl_stat_0.05[ ( which( cur_df$cl_stat_0.05 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 

 df_5[4,j] <- -cur_df$delta[ which( cur_df$np_stat_0.05 == 'yes')[1] ]
 print( 'np' ) 
 print( length( which( cur_df$np_stat_0.05[ ( which( cur_df$np_stat_0.05 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 
 
 
  if(  length( which( cur_df$nm_stat_0.05 == 'yes') ) >0 ){
 df_5[5,j] <- -cur_df$delta[ which( cur_df$nm_stat_0.05 == 'yes')[1] ]
 print( 'nm' ) 
 print( length( which( cur_df$nm_stat_0.05[ ( which( cur_df$nm_stat_0.05 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 
  }
 
  
 df_1[3,j] <- -cur_df$delta[ which( cur_df$cl_stat_0.1 == 'yes')[1] ]
 print( 'cl' ) 
 print( length( which( cur_df$cl_stat_0.1[ ( which( cur_df$cl_stat_0.1 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 


  df_1[4,j] <- -cur_df$delta[ which( cur_df$np_stat_0.1 == 'yes')[1] ]
 print( 'np' ) 
 print( length( which( cur_df$np_stat_0.1[ ( which( cur_df$np_stat_0.1 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 
   
 

  if(  length( which( cur_df$nm_stat_0.1 == 'yes') ) >0 ){
 df_1[5,j] <- -cur_df$delta[ which( cur_df$nm_stat_0.1 == 'yes')[1] ]
 print( 'nm' ) 
 print( length( which( cur_df$nm_stat_0.1[ ( which( cur_df$nm_stat_0.1 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 
  }
 
  
}



library(fmsb)

# Set graphic colors
library(RColorBrewer)
colors_border=c(  rgb(0,1,0.6,0.9), rgb(1,0.2,0.4,0.6) ,  rgb(0,0.6,1,0.7) )
colors_in=c( rgb(0,1,0.6,0.4), rgb(1,0.2,0.4,0.4) , rgb(0,0.6,1,0.2) )


# plot with default options:
radarchart( df_1  , axistype=1 , 
    #custom polygon
    pcol=colors_border , pfcol=colors_in , plwd=2 , plty=1,
    #custom the grid
   cglcol="grey", cglty=1, axislabcol="black",  cglwd=0.8, caxislabels=seq(-2,0,0.5),
    #custom labels
    vlcex=1 
    )

# Add a legend
legend(x=1.5, y=1, legend = rownames(df_1[-c(1,2),]), bty = "n", pch=20 , col=colors_in , text.col = "grey", cex=1.2, pt.cex=3)






##################
#reverse


setwd( '~/Desktop/nmANOVA/reverse_413' )
file_names <- as.list( dir( pattern="reverse_res_413*" ) )

res <- list()

for( i in 1:length( file_names ) ) {
  
  load( file_names[[i]] ) 
  res[[i]] <- res_df
  
  
}


df<- ldply( res, as.data.frame )


df <- 
  df %>%
  #dplyr::select( -m1, -m2, -m3, -m4 )%>%
  group_by( dist_method, vector_num, delta )%>%
  summarise_each( funs = mean) %>%
  ungroup()

cor( df$np_pval, df$nm_pval )




df_thr <- 
  df %>%
  mutate( nm_stat_0.05 = ifelse( nm_pval <= 0.05, 'yes', 'no' ), nm_stat_0.1 = ifelse( nm_pval <= 0.1, 'yes', 'no' ),
          np_stat_0.05 = ifelse( np_pval <= 0.05, 'yes', 'no' ), np_stat_0.1 = ifelse( np_pval <= 0.1, 'yes', 'no' )
           )%>%
  mutate( group = paste( dist_method, vector_num, sep = '_' ) )
  
all_groups <- unique( df_thr$group )

df_5 <- as.data.frame( matrix(0, ncol = length( all_groups ), nrow = 4) )
colnames( df_5 ) <- all_groups
rownames( df_5 ) <- c( 'max', 'min',  'np', 'nm' )
df_5[1, ] <- 0
df_5[2, ] <- -2

df_1 <- df_5

for( j in 1:length( all_groups ) ){
  
  cur_df <- 
    df_thr %>%
    filter( group == all_groups[j] ) %>%
    arrange( delta )
  
  


 df_5[3,j] <- -cur_df$delta[ which( cur_df$np_stat_0.05 == 'yes')[1] ]
 print( 'np' ) 
 print( length( which( cur_df$np_stat_0.05[ ( which( cur_df$np_stat_0.05 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 
 
 df_5[4,j] <- -cur_df$delta[ which( cur_df$nm_stat_0.05 == 'yes')[1] ]
 print( 'nm' ) 
 print( length( which( cur_df$nm_stat_0.05[ ( which( cur_df$nm_stat_0.05 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 
 
 
  


 df_1[3,j] <- -cur_df$delta[ which( cur_df$np_stat_0.1 == 'yes')[1] ]
 print( 'np' ) 
 print( length( which( cur_df$np_stat_0.1[ ( which( cur_df$np_stat_0.1 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 
 
 df_1[4,j] <- -cur_df$delta[ which( cur_df$nm_stat_0.1 == 'yes')[1] ]
 print( 'nm' ) 
 print( length( which( cur_df$nm_stat_0.1[ ( which( cur_df$nm_stat_0.1 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 
 
 
  
}



library(fmsb)

# Color vector
colors_border=c( rgb(0.2,0.5,0.5,0.9), rgb(0.8,0.2,0.5,0.9) , rgb(0.7,0.5,0.1,0.9) )
colors_in=c( rgb(0.2,0.5,0.5,0.4), rgb(0.8,0.2,0.5,0.4) , rgb(0.7,0.5,0.1,0.4) )

# plot with default options:
radarchart( df_1  , axistype=1 , 
    #custom polygon
    pcol=colors_border , pfcol=colors_in , plwd=4 , plty=1,
    #custom the grid
    cglcol="grey", cglty=1, axislabcol="grey", caxislabels=seq(-2,0,5), cglwd=0.8,
    #custom labels
    vlcex=0.8 
    )

# Add a legend
legend(x=1.5, y=1, legend = rownames(df_1[-c(1,2),]), bty = "n", pch=20 , col=colors_in , text.col = "grey", cex=1.2, pt.cex=3)




setwd( 'rev_new' )
file_names <- as.list( dir( pattern="reverse_res_413*" ) )

res <- list()

for( i in 1:length( file_names ) ) {
  
  load( file_names[[i]] ) 
  res[[i]] <- res_df
  
  
}


df<- ldply( res, as.data.frame )


df <- 
  df %>%
  #dplyr::select( -m1, -m2, -m3, -m4 )%>%
  group_by( dist_method, vector_num, delta )%>%
  summarise_each( funs = mean) %>%
  ungroup()

cor( df$np_pval, df$nm_pval )




df_thr <- 
  df %>%
  mutate( nm_stat_0.05 = ifelse( nm_pval <= 0.05, 'yes', 'no' ), nm_stat_0.1 = ifelse( nm_pval <= 0.1, 'yes', 'no' ),
          np_stat_0.05 = ifelse( np_pval <= 0.05, 'yes', 'no' ), np_stat_0.1 = ifelse( np_pval <= 0.1, 'yes', 'no' )
           )%>%
  mutate( group = paste( dist_method, vector_num, sep = '_' ) )
  
all_groups <- unique( df_thr$group )

df_5 <- as.data.frame( matrix(0, ncol = length( all_groups ), nrow = 4) )
colnames( df_5 ) <- all_groups
rownames( df_5 ) <- c( 'max', 'min',  'np', 'nm' )
df_5[1, ] <- 0
df_5[2, ] <- -2

df_1 <- df_5

for( j in 1:length( all_groups ) ){
  
  cur_df <- 
    df_thr %>%
    filter( group == all_groups[j] ) %>%
    arrange( delta )
  
  


 df_5[3,j] <- -cur_df$delta[ which( cur_df$np_stat_0.05 == 'yes')[1] ]
 print( 'np' ) 
 print( length( which( cur_df$np_stat_0.05[ ( which( cur_df$np_stat_0.05 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 
 
 df_5[4,j] <- -cur_df$delta[ which( cur_df$nm_stat_0.05 == 'yes')[1] ]
 print( 'nm' ) 
 print( length( which( cur_df$nm_stat_0.05[ ( which( cur_df$nm_stat_0.05 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 
 
 
  


 df_1[3,j] <- -cur_df$delta[ which( cur_df$np_stat_0.1 == 'yes')[1] ]
 print( 'np' ) 
 print( length( which( cur_df$np_stat_0.1[ ( which( cur_df$np_stat_0.1 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 
 
 df_1[4,j] <- -cur_df$delta[ which( cur_df$nm_stat_0.1 == 'yes')[1] ]
 print( 'nm' ) 
 print( length( which( cur_df$nm_stat_0.1[ ( which( cur_df$nm_stat_0.1 == 'yes' ) +1 ):nrow( cur_df ) ] == 'no' ) ) ) 
 
 
  
}

df_1 <- df_1[c(1,2, 4, 3),]

df_11 <- df_1
df_11[3, 3:9] <- NA
library(fmsb)

# Color vector
colors_border=c( rgb(0,0.6,1,0.7), rgb(1,0.2,0.4,0.6) , rgb(0.7,0.5,0.1,0.9) )
colors_in=c( rgb(0,0.6,1,0.2), rgb(1,0.2,0.4,0.4) , rgb(0.7,0.5,0.1,0.4) )

# plot with default options:
radarchart( df_1  , axistype=1 , 
    #custom polygon
    pcol=colors_border , pfcol=colors_in , plwd=4 , plty=1,
    #custom the grid
    cglcol="grey", cglty=1, axislabcol="grey", caxislabels=seq(-2,0,0.5), cglwd=0.8,
    #custom labels
    vlcex=0.8 
    )

# Add a legend
legend(x=1.5, y=1, legend = rownames(df_1[-c(1,2),]), bty = "n", pch=20 , col=colors_in , text.col = "grey", cex=1.2, pt.cex=3)




par(mfrow=c(2,3) , mar=c(2,2,2,1) , oma=c(4,5,1,1) )
 
line <- 6
col <- 6
red <- sort(rep(c(0,0.2,0.4,0.6,0.8,1),col))
green <- rep(c(0,0.2,0.4,0.6,0.8,1),line)
num <- 0
 
for(i in seq(0,1,0.2)){
    num <- num+1
    plot(0, 0, type = "n", xlim = c(0, 1), ylim = c(0, 1), axes = FALSE, xlab = "", ylab = "" )
    colors <- rgb(red,green,i,1)
    mtext(paste("blue = ",i,sep="") , side=3 , line=0.15 , col="blue" , font=2)
    rect(  rep((0:(col - 1)/col),line) ,  sort(rep((0:(line - 1)/line),col),decreasing=T)   ,   rep((1:col/col),line) , sort(rep((1:line/line),col),decreasing=T),  border = "light gray" , col=colors)
    axis(2 , at=c(17,14,11,8,5,2)/18-0.035 , labels=c("0","0.2","0.4","0.6","0.8","1") , tick=F , lty=6 , pos=0.01)
    axis(3 , at=c(1.5 , 3.5 , 5.5 , 7.5 , 9.5 , 11.5)/12-0.045 , labels=c("0","0.2","0.4","0.6","0.8","1") , tick=F , pos=-0.15)
    }
 
mtext("Quantity of red", side=2 , line=34 , col="red" , font=2 , at=1.2)
mtext("Quantity of green", side=1 , line=3 , at=-0.8 , col="forestgreen" , font=2)

  



#DRUGCOMB 
#Figures 7, 8 (Supplementary) and Table 3
#DrugComb table for O'Neil dataset is in summary_table_ONEIL.xlsx
#p-values in all_res, filters for cell_line, heatmaps at the end


#all_res contains nmANOVA p-values

library( pheatmap )
oneil <- read.xlsx("summary_table_ONEIL.xlsx")
all_cl <- unique( oneil$cell_line_name )

#cur_cl <- 'LOVO'
all_res <- list()
k <- 0
for (ii in 1:length( all_cl ) ){
 

#for( j in 1:4){
   k <- k+1
        cur_cl <- all_cl[ii]
        # A2058 cell line
        oneil_a2058 = oneil[oneil$cell_line_name==cur_cl,]
       #A_oneil_a2058_single <- 
       # oneil_a2058 %>%
       #  group_by( drug_row,drug_col )%>%
       #  dplyr::slice(j)
  
        A_oneil_a2058_single <- oneil_a2058 
        oneil_a2058_single = ddply(A_oneil_a2058_single, .(drug_row,drug_col), summarise, 
                                   css_row = mean(css_row), css_col = mean(css_col),
                                   ri_row = mean(ri_row), ri_col = mean(ri_col))
        # combo
        oneil_a2058_1 = oneil_a2058_single[,c('drug_row','drug_col','css_row')]
        oneil_a2058_2 = oneil_a2058_single[,c('drug_col','drug_row','css_col')]
        # single drug
        oneil_a2058_3 = oneil_a2058_single[,c('drug_col','drug_row','ri_row')]
        oneil_a2058_4 = oneil_a2058_single[,c('drug_col','drug_row','ri_col')]
        oneil_a2058_3$drug_col=oneil_a2058_3$drug_row
        oneil_a2058_4$drug_row=oneil_a2058_4$drug_col
        colnames(oneil_a2058_2) = colnames(oneil_a2058_1)
        colnames(oneil_a2058_3) = colnames(oneil_a2058_1)
        colnames(oneil_a2058_4) = colnames(oneil_a2058_1)
        oneil_a2058_all = rbind(oneil_a2058_1, oneil_a2058_2, oneil_a2058_3, oneil_a2058_4)
        # css_mat: asymetric
        
        # ri values on the diagonal
        css_mat = dcast(oneil_a2058_all, drug_row ~ drug_col, value.var = "css_row", fun.aggregate = mean)
        rownames(css_mat) = css_mat$drug_row
        css_mat = css_mat[,-1]
      
        
        # impute NA with the average of RI of single drugs
        na_index = which(is.na(css_mat)==T, arr.ind = T)
        for (i in 1:nrow(na_index)){
          css_mat[na_index[i,1], na_index[i,2]] = (css_mat[na_index[i,1],na_index[i,1]] + css_mat[na_index[i,2],na_index[i,2]])/2 
        }
        
        
        
        # to be used by hclust, force it to be symmetric by taking lower triangle
       # css_mat2 = 1 - abs(cor(css_mat)) # use correlation as distance
        css_mat2 =  1 - abs(cor(css_mat))
        css_mat2 = 1 - abs(cor(css_mat)) # use correlation as distance, column wise
        css_mat3 = 1 - abs(cor(t(css_mat))) # row wise, you have two versions of correlation matrix
# then merge these two correlation matrix, lower diagnoal as css_mat2, upper diagonal as css_mat3
        css_mat4 = css_mat2
        css_mat4[upper.tri(css_mat4)] <- t(css_mat3)[upper.tri(css_mat3)] # take lower triangle
        clusters <- hclust(as.dist(css_mat2))
        clusterCut <- cutree(clusters, 2)
        
        #pheatmap(css_mat2, clustering_distance_rows = as.dist(css_mat2),
        # clustering_distance_cols = as.dist(css_mat2),
        #clustering_method = "complete")
        

    

      
        # to run nmanova, it shall produce similarly two best clusters, determined by p-values
        partition <- paste( 'group_', clusterCut, sep = '' )
        #css_mat3 = 1 - abs(cor(css_mat))
        res <- nmANOVA( ( css_mat4 ), partition,1)
        #View(res$summary)
        all_res[[k]] <- res$summary
        all_res[[k]]$cell_line <- cur_cl
        all_res[[k]]$mat <- 'css_mat'
        all_res[[k]]$num <- k
        all_res[[k]]$cluster_num <- 2
        #all_res[[k]]$slice <- j
        
        if(res$summary$p_value < 0.05){
       print( cur_cl)
        plot(clusters)
        #css_mat2_ordered <- css_mat2[clusters$order,clusters$order]
        #pheatmap( t( as.matrix( css_mat2_ordered ) ), cluster_cols = F, cluster_rows = F )
        css_mat_ordered <- css_mat4[clusters$order,clusters$order]
        pheatmap( t( as.matrix( css_mat_ordered ) ), cluster_cols = F, cluster_rows = F )
       colnames( css_mat4 )[which(clusterCut ==2 )]
        }
}
 

        


all_res <- ldply( all_res, data.frame )


sel_cell_lines <- c( 'VCAP', 'OVCAR3', 'CAOV3', 'HT144', 'ES2', 'EFM192B', 'HCT116' ) # those gave us significant p-values

for( i in 1:length( sel_cell_lines ) ) {
  
  cur_cl <- sel_cell_lines[i]
        # A2058 cell line
        oneil_a2058 = oneil[oneil$cell_line_name==cur_cl,]
       #A_oneil_a2058_single <- 
       # oneil_a2058 %>%
       #  group_by( drug_row,drug_col )%>%
       #  dplyr::slice(j)
  
        A_oneil_a2058_single <- oneil_a2058 
        oneil_a2058_single = ddply(A_oneil_a2058_single, .(drug_row,drug_col), summarise, 
                                   css_row = mean(css_row), css_col = mean(css_col),
                                   ri_row = mean(ri_row), ri_col = mean(ri_col))
        # combo
        oneil_a2058_1 = oneil_a2058_single[,c('drug_row','drug_col','css_row')]
        oneil_a2058_2 = oneil_a2058_single[,c('drug_col','drug_row','css_col')]
        # single drug
        oneil_a2058_3 = oneil_a2058_single[,c('drug_col','drug_row','ri_row')]
        oneil_a2058_4 = oneil_a2058_single[,c('drug_col','drug_row','ri_col')]
        oneil_a2058_3$drug_col=oneil_a2058_3$drug_row
        oneil_a2058_4$drug_row=oneil_a2058_4$drug_col
        colnames(oneil_a2058_2) = colnames(oneil_a2058_1)
        colnames(oneil_a2058_3) = colnames(oneil_a2058_1)
        colnames(oneil_a2058_4) = colnames(oneil_a2058_1)
        oneil_a2058_all = rbind(oneil_a2058_1, oneil_a2058_2, oneil_a2058_3, oneil_a2058_4)
        # css_mat: asymetric
        
        # ri values on the diagonal
        css_mat = dcast(oneil_a2058_all, drug_row ~ drug_col, value.var = "css_row", fun.aggregate = mean)
        rownames(css_mat) = css_mat$drug_row
        css_mat = css_mat[,-1]
      
        
        # impute NA with the average of RI of single drugs
        na_index = which(is.na(css_mat)==T, arr.ind = T)
        for (i in 1:nrow(na_index)){
          css_mat[na_index[i,1], na_index[i,2]] = (css_mat[na_index[i,1],na_index[i,1]] + css_mat[na_index[i,2],na_index[i,2]])/2 
        }
        
        
        
        # to be used by hclust, force it to be symmetric by taking lower triangle
       # css_mat2 = 1 - abs(cor(css_mat)) # use correlation as distance
        css_mat2 =  1 - abs(cor(css_mat))
        css_mat2 = 1 - abs(cor(css_mat)) # use correlation as distance, column wise
        css_mat3 = 1 - abs(cor(t(css_mat))) # row wise, you have two versions of correlation matrix
# then merge these two correlation matrix, lower diagnoal as css_mat2, upper diagonal as css_mat3
        css_mat4 = css_mat2
        css_mat4[upper.tri(css_mat4)] <- t(css_mat3)[upper.tri(css_mat3)] # take lower triangle
        clusters <- hclust(as.dist(css_mat4))
        clusterCut <- cutree(clusters, 2)
        
        #pheatmap(css_mat2, clustering_distance_rows = as.dist(css_mat2),
        # clustering_distance_cols = as.dist(css_mat2),
        #clustering_method = "complete")
        

    

      
        # to run nmanova, it shall produce similarly two best clusters, determined by p-values
        partition <- paste( 'group_', clusterCut, sep = '' )
        #css_mat3 = 1 - abs(cor(css_mat))
        res <- nmANOVA( ( css_mat4 ), partition,1)
        
        
        if(res$summary$p_value < 0.05){
       print( cur_cl)
        plot(clusters)
        #css_mat2_ordered <- css_mat2[clusters$order,clusters$order]
        #pheatmap( t( as.matrix( css_mat2_ordered ) ), cluster_cols = F, cluster_rows = F )
        css_mat_ordered <- css_mat4[clusters$order,clusters$order]
        colnames( css_mat_ordered ) <- toupper( colnames( css_mat_ordered ) )
        rownames( css_mat_ordered ) <- toupper( rownames( css_mat_ordered ) )
        pheatmap( t( as.matrix( css_mat_ordered ) ), cluster_cols = F, cluster_rows = F, main = cur_cl,fontsize_row = 10, fontsize_col = 10  )
       colnames( css_mat4 )[which(clusterCut ==2 )]
        }
  
  
}

